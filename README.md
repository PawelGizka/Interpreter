I implemented all features required to get 30 points.

My solution consist of:
- parser directory with parser related files generated by bnfc compiler,
- Common.hs - data types used in all program,
- TypeCheck.hs - module responsible for static type checking,
- GarbageCollector.hs - module which allows garbage collection,
- Main.sh - main interpreter code,

In my.ebnf file is complete language grammar.   

Whole program is written in monadic style with use of monad transformers.

Program state is divided into environments and one global store.
Every function has its own environment. 

Garbage collection procedure is launched after every 1000000 insertion to store.
It marks all available locations in store (including locations referenced by closures)
and removes not marked.

Compile:
```make```

Launch:
```./interpreter programFile```

Pass arguments:
```./interpreter programFile argument1 argument2 ...```

Program examples are in ``good`` subdirectory.
Wrong program examples are in ``bad`` subdirectory.

For example:
```./interpreter good/hello```
